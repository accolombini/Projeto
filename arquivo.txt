Testando git - primeiros passos
git init (ativa o git para o projeto em questão)
git config --global
git config --global user.name ... (nome do usuário)
git config --global user.email ... (email do usuário)
git config --global -l (lista todas as configurações)
git config --global core.editor <nome do editor desejado - notepad, por exemplo> (define um editor de trabalho para o git)
git status (status dos arquivos controlados pelo git)
git add <nome do arquivo> (adiciona o arquino na stage para que o git passe a controlá-lo)
git commit -m 'Uma mensagem clara do que foi feito desde a última alteração - procure ser claro aqui' <tira uma foto do arquivo naquele momento>
git add . (adiciona todos os arquivos do diretório controlado na stage)
git commit -am 'Uma mensagem clara do que foi feito desde a última alteração' (este comando realiza a adição na stage e realiza o commit de uma vez)
É importante destacar que o comando git commit -am só é válido para arquivos que já estão senfo rastreados (não se aplica na primeira vez)
git log (exibe o histórico de commits do(s) arquiv(s) controlado(s) --> Project history)
Atenção quanto o log não couber em uma tela aparecerá o sinal de : para sair da tela de log é preciso preciosar a tecla "q"
git checkout <código do commit exemplo: 071bb901c4cf20bb8b00f7c7497eee5f5d31b243> (nos poermite visualizar o arquivo naquele instante do snapshot)
git checkout master (para retornar para o master - arquivo atual ou último arquivo comitado)
git clone (https://nome do repositório criado no github para onde deverão ser clonados todos os nossos arquivos --> Neste caso não há necessidade do git init)
Atenção sempre que um novo arquivo for adicionado ao projeto ele precisa ser adicionado com o comando
git add <nome do arquivo>
E para o primeiro commit não se esqueça de usar a cláusula -m, assim:
git commit - m 'Comentário inicial do arquivo criado'
Para subir os arquivos comitados para o GitHub usamos o comando:
git push (este comando remete todos os arquivos comitados localmente para o repositório no GitHub)
Atenção --> cuidado com o repositório criado no GitHub e clonado localmente, procure ter um repositório especifico - ok
git pull (este comando traz para o repositório local tudo o que foi criado remotamente)
Vamos agora iniciar uma nova fase, neste momento trabalharemos com branchs e faremos merges das branches com a branch master
Para criar uma nova branch usamos o seguinte comando:
git branch <nome da branch> (simples assim)
Para visualizar as branches do projeto usamos o seguinte comando:
git branch (observe que neste caso não especificamos um mome --> nosso interesse é no retorno das branches dos projeto)
Para assessarmos a nova branch e realizarmos nosso trabalho todo nela --> digo, a partir daqui estaremos fazendo commits na nova-branch
git checkout <nome da branch> (este comando direciona nossas ações para a nova branch --> Nossos commits serão realizado aqui)
Para retornar para a branch master usamos o comando:
git checkout master (observe que estamos nomeando a git como master --> em palavras estamos acessando novamente a branch master)
Podemos rastrear os commites em uma branch específica da mesma forma que fazíamos na branch master ou seja, usando o comando:
git log  (você irá observar que todos os commites serão listados da branch master e da branch criada, lembra os commites são rastreados por históricos)
Atenção se voltarmos para a branch master iremos observar que o commit realizado na branch assim como o documento alterado não existem na branch master.
Vamos ver agora como realizar o merge de branches do tipo fast-forward (aquelas em que não foram realizados commits na branch master)
Importante --> o merge é ralizado a partir da branch master (na branch master eu peço para realizar o merge). Isso é feito com o comando:
git merge <nome da branch que desejo fazer o merge>
Um comando interessante será visto a seguir, seu objeto é apresentar um minigráfico da estrutura de commit, veja o comando:
git log --graph (este é um comando interessante quando se trabalha com várias branches)
Após fazermos o mege de uma branch com a master, podemos excluir a branch antiga, para isso usamos o comando:
git branch -d <nome da branch a ser excluída>
Posso agora fazer uma consulta às branches usando o comando a seguir:
git branch
Vamos agora realizar branches merge recursive strategy (neste caso foram realizados commits nas duas branch --> na master e na branch criada)
Podemos usar um comando um pouco mais interessante que nos permite criar um nova branch e entrar dentro dela, veja o comando a seguir:
git checkout -b <nome da branch>
Como poderemos term muita informação na tela e tornar o trabalho visulamente complexo, temos um comando que simplifica um pouco as coisas, veja a seguir:
git log --graph --oneline (ele diz para o graph resumir tudo a uma única linha)
Vamos agora trabalhar com conflitos nas branches --> isso ocorre quando alterações na master coincidem ou colidem com alterações feitas na branch.
Posso usar uma opção para sinalizar quais commites quero que sejam incluídos na branch, observe:
git commit -am 'mensagem' (observe o uso da flag -am ela inclui todas as alterações num único commit)
Atenção --> a resolução do conflito é competência do usuário, logo sua palavra final irá definir o que fica o que sai e a ordem.
