Testando git - primeiros passos
git init (ativa o git para o projeto em questão)
git config --global
git config --global user.name ... (nome do usuário)
git config --global user.email ... (email do usuário)
git config --global -l (lista todas as configurações)
git config --global core.editor <nome do editor desejado - notepad, por exemplo> (define um editor de trabalho para o git)
git status (status dos arquivos controlados pelo git)
git add <nome do arquivo> (adiciona o arquino na stage para que o git passe a controlá-lo)
git commit -m 'Uma mensagem clara do que foi feito desde a última alteração - procure ser claro aqui' <tira uma foto do arquivo naquele momento>
git add . (adiciona todos os arquivos do diretório controlado na stage)
git commit -am 'Uma mensagem clara do que foi feito desde a última alteração' (este comando realiza a adição na stage e realiza o commit de uma vez)
É importante destacar que o comando git commit -am só é válido para arquivos que já estão senfo rastreados (não se aplica na primeira vez)
git log (exibe o histórico de commits do(s) arquiv(s) controlado(s) --> Project history)
Atenção quanto o log não couber em uma tela aparecerá o sinal de : para sair da tela de log é preciso preciosar a tecla "q"
git checkout <código do commit exemplo: 071bb901c4cf20bb8b00f7c7497eee5f5d31b243> (nos poermite visualizar o arquivo naquele instante do snapshot)
git checkout master (para retornar para o master - arquivo atual ou último arquivo comitado)
git clone (https://nome do repositório criado no github para onde deverão ser clonados todos os nossos arquivos --> Neste caso não há necessidade do git init)
Atenção sempre que um novo arquivo for adicionado ao projeto ele precisa ser adicionado com o comando
git add <nome do arquivo>
E para o primeiro commit não se esqueça de usar a cláusula -m, assim:
git commit - m 'Comentário inicial do arquivo criado'
Para subir os arquivos comitados para o GitHub usamos o comando:
git push (este comando remete todos os arquivos comitados localmente para o repositório no GitHub)
Atenção --> cuidado com o repositório criado no GitHub e clonado localmente, procure ter um repositório especifico - ok
git pull (este comando traz para o repositório local tudo o que foi criado remotamente)
Vamos agora iniciar uma nova fase, neste momento trabalharemos com branchs e faremos merges das branches com a branch master
Para criar uma nova branch usamos o seguinte comando:
git branch <nome da branch> (simples assim)
Para visualizar as branches do projeto usamos o seguinte comando:
git branch (observe que neste caso não especificamos um mome --> nosso interesse é no retorno das branches dos projeto)
Para assessarmos a nova branch e realizarmos nosso trabalho todo nela --> digo, a partir daqui estaremos fazendo commits na nova-branch
git checkout <nome da branch> (este comando direciona nossas ações para a nova branch --> Nossos commits serão realizado aqui)
Para retornar para a branch master usamos o comando:
git checkout master (observe que estamos nomeando a git como master --> em palavras estamos acessando novamente a branch master)
Podemos rastrear os commites em uma branch específica da mesma forma que fazíamos na branch master ou seja, usando o comando:
git log  (você irá observar que todos os commites serão listados da branch master e da branch criada, lembra os commites são rastreados por históricos)
Atenção se voltarmos para a branch master iremos observar que o commit realizado na branch assim como o documento alterado não existem na branch master.
Vamos ver agora como realizar o merge de branches do tipo fast-forward (aquelas em que não foram realizados commits na branch master)
Importante --> o merge é ralizado a partir da branch master (na branch master eu peço para realizar o merge). Isso é feito com o comando:
git merge <nome da branch que desejo fazer o merge>
Um comando interessante será visto a seguir, seu objeto é apresentar um minigráfico da estrutura de commit, veja o comando:
git log --graph (este é um comando interessante quando se trabalha com várias branches)
Após fazermos o mege de uma branch com a master, podemos excluir a branch antiga, para isso usamos o comando:
git branch -d <nome da branch a ser excluída>
Posso agora fazer uma consulta às branches usando o comando a seguir:
git branch
Vamos agora realizar branches merge recursive strategy (neste caso foram realizados commits nas duas branch --> na master e na branch criada)
Podemos usar um comando um pouco mais interessante que nos permite criar um nova branch e entrar dentro dela, veja o comando a seguir:
git checkout -b <nome da branch>
Como poderemos term muita informação na tela e tornar o trabalho visulamente complexo, temos um comando que simplifica um pouco as coisas, veja a seguir:
git log --graph --oneline (ele diz para o graph resumir tudo a uma única linha)
Vamos agora trabalhar com conflitos nas branches --> isso ocorre quando alterações na master coincidem ou colidem com alterações feitas na branch.
Posso usar uma opção para sinalizar quais commites quero que sejam incluídos na branch, observe:
git commit -am 'mensagem' (observe o uso da flag -am ela inclui todas as alterações num único commit)
Atenção --> a resolução do conflito é competência do usuário, logo sua palavra final irá definir o que fica o que sai e a ordem.
Para que você insira seu projeto local na nuvem --> siga os passos a seguir:
Crie um repositório no GitHub simples --> não adicone nada
Na sua máquina use o comando:
git push --set-upstream projeto master (projeto é o nome de seu repositírio)
crie no git hub o arquivo readme.md
Na sua máquina local faça:
git pull (agora você esta sincroniado e atualizado)
Vamos falar agora da ferramenta ISSUES --> podemos usar esta ferramenta por vários motivos, são os mais relevantes:
1-  Relatar o Rastreio de Bugs --> nesta ISSUES queremos relatar bugs no projeto e acompanhar a solução destes bugs.
2- Sugestão de Ferramentas para o projeto
As ISSUES nos permitem fazermos um histórico de todas as alterações e uso das ferramentas, em outras palavras
conseguimos desta forma documentar passo a passo tudo o que foi feito para resolver bugs ou no desenvolvimento das novas ferramentas
Criando e resolvendo ISSUES:
1- No gitHub na guia do projeto que está trabalhando há um botão chamada ISSUES --> abre-se uma tela e nela você tem a possibilidade
de definir o título de sua ISSUES (uma boa dica --> as ISSUES pode auxiliá-lo a fazer uma boa gestão do seu projeto)
2- Cria-se a issue faz um clone no seu repositório local --> se for possível atenda de imediato a ISSUE e realize o commit
3- Se o commit realizado resolveu a ISSUE documente isso no GITHUB e faça um breve Comentário.
Criando branches
Você pode optar, por exemplo, por criar uma nova branch para atender a ISSUE criada, desta forma, você evita alterar a branch master
Nota: você ao realizar um commit para atender uma ISSUE específica após os comentários poderá acrescentar # <número da ISSUE>
O git entenderá que o commit feito refere-se a uma ISSUE específica, no caso, (número da ISSUE)
ATENÇÃO: após esse commit feito você deverá fazer um git push, correto? Pois é, isso não irá funcionar, pois o git entende que
os commits devem ser direcionados para a branch master, o que não é o caso neste momento. Para resolver isso, use o comando:
git push origin <branch destino>
ISSUES COMO FERRAMENTA COLABORATIVA
Observe que você pode desabilitar uma ISSUE, note que, por padrão, as ISSUES veêm ativadas, para desativá-las vá em
Features e desmarque a guia ISSUES
Num cenário colaboratívo, um colaborador também possui a autonomia para criar ISSUES e realizar solicitações sobre o projeto
Para isso, este colaborador deve acessar a página do projeto e criar uma ISSUE (processo anteriormente visto)
IMPORTANTE: se na área de comentário do commit for inserida a palavra "closes" seguida do id da ISSUE (# <NUM ISSUE)
Quando a palavra closes seguida do identificador da ISSUE for utilizada, ao realizar o git push a ISSUE será encerrada
Vamos agora ver como trabalhar com LABELS em ISSUES --> Para adicionar um LABEL, basta ir no github, selecionar a ISSUE
e escolher a opção LABEL, observe que o github tráz alguns LABELS padronizados que poderá usar diretamente, mas você é 
livre para criar os seus. Ao usar um LABEL você poderá fazer uma gestão visual do seu projeto através por exemplo das cores 
utilizadas na definição do seu LABEL
Outra prática importante é trabalhar com EMAILS E CITAÇÕES EM ISSUES
O interessante é que ao escrever, alterar produzir na ISSUE é enviado um e-mail a todos os colaboradores com interesse na ISSUE
em questão. O colaborador pode enviar uma mensagem para uma pessoa específica, para isso, basta usar o símbolo de @ e o nome
do colaborador que deseja enviar a mensagem
ASSINATURAS e ENCERRAMENTO DAS ISSUES
No topo do lado direito no github há a opção Assignees onde é possível sinalizar quem saão as pessoas cadastradas para assinar 
essa ISSUE --> essa ferramenta ajuda pessoas a acompanharem as ações realizadas numa ISSUE.
ISSUES e MILESTONES --> Milestones são agregadores de ISSUES, em termos gerais, podemos dizer que os Milestones nos permitem agrupar
uma série de ISSUES que estão relacionadas entre si.
Para criar um Milestone, no github no ambiente de ISSUE, escolha a opção Milestones. No Milestones, definimos uma data de término 
para a tratativa do problema. Isso faz com que o Git passe a gerenciar o cronograma para você.
Uma vez criado o Miletsone, retornamos para as ISSUES criadas e selecionamos as ISSUES que devem ser incluídas neste Milestone.
Feito isso, ao retornar para o ambiente de Milestone, nos será apresentado uma ferramenta visual para acompanharmos o que está 
acontecendo com ass ISSUES.
INTERESSANTE --> ao fazermos o commit para a solução de uma ISSUE, na egião de comentários, podemos usar a palavra "fixes" # <num ISSUE>
para sinalizar que a demanda solicitada na ISSUE foi realizada.
Na troca de mensagens no ambiente de ISSUES você pode usar emojis, para ativá-los basta digitar : que um menu pop up lhe pemite escolher um emoji 
Atenção, uma pessoa externa pode encerrar uma ISSUE, principalmente tendo ele gerado a ISSUE.
AGORA ATENÇÃO --> vamos trabalhar com GIT - CHECKOUT & RESET
AGORA VAMOS FALAR SOBRE --> CHECKOUT & RESET (Git e GitHub intermediário)
Como podemos desfazer ações realizadas no Git e Github?
Atenção --> estes comando vão modificar o Project History e isso é um problema, portanto, tome muito cuidado, principalmente se as alterações
já tiverem sido publicadas no GitHub e tiverem sido compartilhadas.
Interessante, antes de você colocar seu arquivo modificado na área de Stage (comando git add .) você pode facilmente alterar o que foi realizado,
para isso devemos usar o comando <git checkout nome_do_arquivo> --> como num passe de mágica as alterações realizadas que não foram para a área de 
stage serão removidas.
Imagine se você foi muito rápido e adicionou as alteraões na stage (comando git add .). Neste caso, ainda assim você pode voltar atrás, mas deverá
usar o comando <git reset head nome_do_arquivo> nós removemos tudo o que foi colocado na área de stage.
Atenção --> ao usar o git reset o arquivo volta para o estado anterior a ser inserido na área de stage, sendo assim, ainda precisamos utilizar o 
git checkout nome do arquivo para remover as alterações.
Indo além --> imagine agora que chegamos ao ponto de realizarmos o commit. Ainda neste caso podemos voltar atrás, veja alguns comandos de apoio
git log --decorate --oneline nos mostra onde está a HEAD (opção --decorate) e em uma linha (opção oneline)
Para voltarmos atrás após realização de um ou mais commits usamos o comando <git reset head^>, onde ^indica o número de passos que queremos retornar,
no caso head^ voltamos um passo de head, para head^^ voltamos dois passos e assim por diante.
Imagine o caso onde queremos parar de rastrear algum arquivo, queremos dizer ao git --> não rastreie mais este arquivo. Neste caso, usamos
O coamndo <git rm --cached a.txt>, mas atenção, o deixar de rastrear não elimina os rastros anteriores do arquivo, isto é,
podemos ter acesso a todas as alterações do arquivo anteriores à sua mudança de status para não rastreável.
Cuidado --> podemos, caso queiramos eliminar todos os rastros dos commits passados, eliminando nosso projeto. Para isso devemos usar
o comando <git reset --hard codigo_do_commit que desevo voltar> no caso de queirer zerar seu projeto você deve voltar ao commit inicial
AGORA VAMOS FALAR DE FORK
Legenda --> Repositório principal (upstream)
Legenda --> Repositório cópia (FORK)
Legenda --> local (que está na sua máquina)
Fork é um conceito que envolve as tecnologias Git GitHub que permite que você fação uma cópia (um clone) de uma repositório 
público quaquer direto para seu repositório, isso permite que você experimente alterações no projeto, uma vez que você não tem acesso
ao repositório que alguém criou. Outra aplicação do Fork é na colaboração de projetos (projetos de terceiros), através do ciclo do Fork
é possível enviar alterações ou sugerir alterações.
Atenção, uma vez realizado um Fork os projetos são ASSÍNCRONOS, isto é, alterações realizadas no projeto principal não refletem na cópia
realizada por você, podemos dizer que as atualizações são independentes. No entanto, podemos querer manter nosso projeto atualizado
(sincronizado) com as alterações feitas no principal, neste caso, devemos fazer uma cópia do nosso Repositório Cópia para nosso
repositório local (clone).
Uma vez no diretório local, você adiciona um link com o diretório principal --> você faz um add remote usando o seguinte comando
<git remote add upstream https://endereço do repositório principal> (observe o uso nome padrão upstream)
Para visualizarmos quantos diretórios remotos fazem parte do nosso fork, usamos o comando <git remote -v>, neste caso, teremos o 
origin que aponto para nosso fork e o upstream que aponta para o diretório principal.
Agora podemos atualizar nosso repositório fazendo <git pull upstream master> --> estamos fazendo uma atualização a partir do nosso
diretório master (branch principal nosso diretório principal). 
Feito isso --> usamos o comando <git push> para sincronizar nosso repositório com o repositório principal
VAMOS AGORA FALAR SOBRE REBASE vs MERGE --> com rebese conseguimos trabalhar tudo o que diz respeito ao Project History
Modificar Project History
Alterar a ordem de commits (podemos alterar a ordem de commits)
Unir commits (podemos unir vários commits em um único)
Modificar mensagem (podemos alterar uma mensagem que por algum motivo não reflita com clareza as alterações realizadas)
IMPORTANTE --> commits não são apenas saves para estabelecer pontos de backup! e sim uma forma de manter um histórico 
cronológico sobre o que aconteceu com nosso projeto, em palavras, commits permitem contar uma história! A história do projeto
Tanto REBASE cquanto MERGE servem para integrar uma branch em outra, mas existem vantagens e desvantagens em usar o REBASE ou
o MERGE, que em linhas gerais podem ser assim descritos:
MERGE --> não altera (destrói) a linha do tempo de uma branch!
MERGE --> pode acabar poluindo a linha do tempo de uma branch!
REBASE --> permite manter um histórico limpo!
CONTROLE DE BRANCH COM REBASE
O controle de branch com REBASE é interessante nos casos em que estamos trabalhando numa branch muito longa e muitos commits
estão aontecendo na branch master e na branch criada, o que resultara no commit de merge, opção que pode não ser interessante 
por não agregar valor ao histórico do projeto. Se esse for o caso o RABASE é uma opção inteligente, pois o mesmo, cria uma área
temporária deslocando os commits da branch de forma que ele fique sempre em condição de realizar uma MERGE do tidpo forward.
Mas atenção, cuidado com REBASE em branches públicas, porque você pode destruir o histórico do seu projeto.
Dica --> cuide bem do seu REBASE! Em outras palavras, nunca faça REBASE, quando você está compartilhando sua branch, ou quando
ela já está pública no GitHub
OBSERVAÇÃO --> quando fazemos um MERGE o ralizamos de dentro da barnch master (fazemos um merge da branc com a master),
mas no caso do RABASE isso é feito dentro da branch que queremos alterar o histórico. No caso de alterar o histórico da branch
em relação à master, devemos usar o comando <git rebase master>, este comando deve ser executado dentro da branch.
Quando é feito o REBASE, todos os commits da master são adicionado à branch. A diferença é que quando voltarmos para a master
e executarmos o MERGE a branch irá realizar um merge forward como desejado, assim, ao usarmos o comando <git log --grahp --oneline>
observaremos que não teremos a árevore das branches, mas sim commits lineares, ou seja, tudo se passa como se todas as operações
tivesses sido executadas na branch master.
Resumindo --> MERGE simples
Merge simples --> git checkout master (DEVE OCORRER DENTRO DA MASTER)
git merge nova-branch
Resumindo --> USO DO REBASE
git chekout nova-branch (DEVE OCORRER DENTRO DA BRANCH PARALELA)
git rebase master (TODOS OS COMMITS SÃO ALOCADOS NA BRANCH NOVA-BRANCH)
git checkout master (VOLTE PARA A MASTER)
git merge nova-branch (REALIZE O MERGE FORWARD COM A NOVA BRANCH)
Este processo remove todos os commits de MERGE e deixa o histórico limpo 
COMO NO MERGE TEMOS CONFLITOS NO REBASE TAMBÉM, como devemos resolver isso?
Da mesma forma que acontece no MERGE é preciso resolver o conflito no REBASE. A 
diferença agora é esse conflito é tratado de dentro da branch criada, ao invés da
branch master como era o caso anteriormente
Resolvido o conflito manualmente, devemos adicionar a solução na stage <git add .> e 
realizar um novo commit, para isso, devemos usar o comando <git rebase --continue>, isso
indica que queremos continuar com nosso processo de REBASE. Caso quiséssemos cancelar o 
processo de REBASE, deveriámos usar o comando <git rebase --abort>, este comando aborta o 
processo de REBASE 
VAMOS VER AGORA O REBASE ITERATIVO 
Atenção --> neste momento estaremos alterando o Projeto History, sendo assim, só faça nas 
branch que não foram compartilhadas, pois estamos alterando o Projeto History
Vamos começar alterando a mensagem de um commit, para isso, usamos o comando 
<git rebase -i hash_do_commit_desejado>. Este comando irá abrir o bloco de notas com todos os commits
já realizados (a partir da árvore de commit tendo como referência o commit pai assinalado no comando git rebase -i), 
o commit que desejar alterar a mensagem, basta subistituir o "pick" pelo "r" de reward
Quando eu salvar esse arquivo (no bloco de notas) cada altareção encontratada será solicitado uma ação 
iterativa para realizar a mudança desejada. Neste momento, será aberta uma janela do bloco de notas 
solicitando a alteração, faça  a alteração desejada e salve novamente o arquivo.
Para alterar a ordem de execução de commits, basta usar o comando <git rebase hash_do_commit_desejado> e em
seguida o comando <get rebase -i hash_do_commit_desejado>. Este comando irá abrir o bloco de notas e lhe
permitirá alterar a ordem de execução dos commits, simplesmente movendo o commit para a posição desejada e
salvando o arquivo do bloco de notas.
Por fim vamos condensar vários commits em um único commit, para isso vamos usar o comando --> SQUASH <s> no bloco de Notas
<git rebase -i hash_do_commit_desejado>, novamente teremos o editor de texto e poderemos agora realizar as alterações
Atenção, o commit que deseja unir aos demais deve receber a opção <s> os outros permancem com <pick>
AGORA VAMOS TRABALHAR COM FORK WORKFLOW 
Pré requisitos para um bom entendimento:
--> Merge & Solução de conflitos
--> Branches 
--> Rebase & Soluçãp de conflitos
--> Trabalhar com ISSUES
O processo de trabalhar com colaboração se baseia no uso do FORK e do Pull Request
Você faz um Pull Request toda vez que desejar que uma alteração que você realizou seja incormporada
no projeto do terceiro. Em outras palavras podemos escrever:
--> Pull Request
--> Enviar alterações para serem incorporadas à um projeto
--> Discussões sobre código
--> Integrar código revisado ao projeto 
Em palavras, o dono do projeto, pode receber suas sugestões avaliá-las e decidir se deve ou não incorporá-las
a seu projeto original, trata-se de uma excelente ferramenta de colaboração
COMO COMEÇA O FLUXO?
--> Tudo começa com o repositório upstream.
--> A partir do upstream fazemos o Fok dele --> criamos o remote
--> A partir do remote fazemos o clone para o repositório local
--> A partir desse momento podemos alterar o projeto que nós clonamos
--> Feito as alterações fazemos o push do nosso repositório local para o nosso repositório remote
--> A partir do nosso remote fazemos um solicitação de Pull request para o repositório upstream (Projeto Principal)
--> Quando é feito um Pull Request, o dono do projeto upstream recebe a solicitação e a branch que você trabalhou as
alterações que está sugerindo para o projeto.
--> Olha que interessante, o dono do projeto pode soliciar alterações em sua proposta e você trabalhará na mesma branch
e está será atualizada toda vez que você fizer um push que isso será atualizado no Pull request, dizemos que , o GitHub 
esta rastreando a branch e não o Pull request.
--> Se o dono do projeto upstream resolver integrar as alterações solicitadas em seu projeto elas farão parte do projeto principal
assim como você gostaria que tivesse sido feito. Cabe a você fazer uma atualização do seu repositório Fork.
VAMOS REVISAR O FLUXO!!!
1- FORK
2- git clone
3- git checkout -b, git add, git commit
4- git push
5- Pull request
git pull upstream, git push (necessário para sincronizar no caso de aceite do dono do repositório upstream)
--> 1- Uma boa dica para se trabalhar com colaboração é dando uma olhada nas ISSUES e avaliando as questões que estão sendo trabalhadas!
--> 2- Outra dica nunca use sua branch master para trabalhar nas alterações que deseja fazer um Pull request --> crie uma nova branch 
isso evita conflitos, principalmente no caso termos várias pessoas trabalhando no projeto.
--> 3- Ao comitar faça sempre referência à ISSUES que motivou seu trabalho, use a diretiva # número da ISSUE
--> 4- Lembre que ao fazer o push deverá se lembrar do seguinte <git push origin nome_da_issue_que_gerou_trabalhos>
--> 5- Por fim, no seu GitHub confira se seu repositório está pronto para merge <Able to merge>, para que não exitam conflitos. Normalmente
donos de repositórios não vão se preocupar em tentar resolver problemas de repositório que foram criados por terceiros, por isso, certifique-se
de que seu repositório esteja <able to merge>
--> 6- Estando tudo ok, é hora de fazer o Pull request, você terá a opçãode escrever uma mensagem (dica use essa opção)
--> 7- Feito isso, nossa branch é adicionada ao projeto principal e o dono do projeto tem acesso a nossa branch e todos os commits que realizarmos
--> 8- A partir desse ponto o dono do projeto poderá integrar nossas solicitações ao seu projeto ou realizar algum pedido de alteração ou complemento
--> 9- Neste momento, se o dono do repositório entender que está tudo ok, ele poderá fazer o <Merge pull request> integrando assim nossa branch ao 
projeto principal
--> 10- Uma coisa interessante é que após 9 se adicionarmos na seção de comentários a diretiva <closes #num_da_issue> a issue será encerrada
TUDO MUITO LEGAL, MAS E OS CONFLITOS --> Vamos agora tratar de Pull Request Merge & conflitos
Para se manter sincronizado é necessário que você vá ao seu diretório (na branch que está trabalhando) e utilize o comando 
<git remote add upstream (endereço do diretório upstream)>, em seguida você deve ir para a branch master <git checkout master> e
em seguida atualizar seu repositório com o comando <git pull upstream master>, note que queremos a branch master que está no repositório upstream
IMPORTANTE --> com nosso diretório atualizado, devemos iniciar uma nova branch para realizarmos as novas alterações.
--> No caso de não conseguirmos a mensagem de <Able to merge>, estamos diante de um conflito, neste caso, cabe a nós resolvermos o problema
para que o dono do projeto upstream não tenha que se preocupar com isso.
--> Para tratar de conflitos:
--> 1- Retorno ao meu projeto
--> 2- Vou para a branch que estou trabalhando o Pull request
--> 3- Faço agora o pedido de atualização (dentro da branch que estou trabalhando --> não na minha master)
--> 4- Para atualizar uso o comando <git pull upstream master>, observe que quero atualizar a branch master do upestream na minha branch de trabalho
--> 5- Feito isso, vá para o arquivo que trabalhou e resolva o conflito
--> 6- Resolvido o conflito devemos adicionar a stage <git add .> e em seguida realizar um commit
--> 7- Agora devemos fazer um push da nossa branch para o respositório origin com o comando <git push origin nossa_barnch>, estamos neste momento
fazendo um push para o meu repositório remoto (Fork) e como esse Fork esta atrealado ao repositório upstream através de um pull request isso
nos garante que todas as alterações realizadas em nossa branch reflitam no repositório upstream.
--> 8- Volte agora ao GitHub e poderá visualizar as alterações realizadas. Eliminados a situação de conflitos, estmoa prontos para recebermos o merge
--> 9- Lembre que ao fazer o merge aproveite para fechar a ISSUE sob discussão com a diretiva <closes #num_da_issue>
--> 10- Por fim, caso queira, você poderá raastrear todo histórico das ISSUES normalmente (mesmo elas estando fechadas)
ATENÇÃO --> os passos acima foram feitos em cima de MERGE e como sabemos eles podem poluir um pouco nosso Project History o que pode 
não ser interessante, ou até mesmo gerar um incômodo ao usuário dono do diretório upstream. Uma boa alternativa é o uso do REBASE!
PULL REQUEST REBASE & CONFLITOS
ATENÇÃO --> Antes de qualquer ação não se esqueça de sincronizar sua master e criar uma nova branch.
--> 1- git checkout master
--> 2- git pull upstream master (como sincronizamos nossa master)
--> 3- git checkout -b <nome_da_issue> (criamos uma nova branch para os trabalharemos)
--> 4- git log --oneline --grahp (é de bom tom sempre analisar a situação do nosso projeto)
--> 5- Faz se a alteração no arquivo, adicona, faz o commit, faz o push e em seguida voltamos ao GitHub para fazermos o Pull request
--> 6- Não se esqueça de avaliar se seu pedido de Pull request está pronto para receber um merge <Able to merge>
--> 7- Verifique a existência ou não de conflitos
--> 8- Na existência de problemas, devemos retornar ao Visual Code em nosso projeto
--> 9- Atenção, não se esqueça se queremos usar o Rebase, não devemos fazê-lo em um diretório compartilhado, pois como já sabemos
isso afeta o Project History, para solucionar isso, devemos:
--> 10- Criar uma nova branch a partir da branch que estavamos trabalhando anteriormente <git checkout -b Nome_issue_v2>, mantemos
o nome da ISSUE e acrescentamos v2 (versão 2)
--> 11- Agora faremos o sincronismo com o upstream <git pull upstream master --rabase> (observe o uso da flag --rebase)
ela é necessária para tratarmos do problema de conflito sem o uso de merges e utilizando a iteratividade do rebase.
--> 12- Abra o arquivo conflituoso e trate do conflito manualmente.
--> 13- Continuamos no nosso processo de rebase iterativo, para isso, adicionamos na stage <git add .> e em seguida fazemos o
<git rebase --continue>, em outras palavras, estamos dizendo que queremos continuar no nosso processo de rebase
--> 14- Podemos agora usar o comando <git log --oneline --graph> para analisarmos a situação
--> 15- Fazemos agora um push da nossa nova branch com o comando <git push origin nome_da_branch>
--> 16- Neste ponto devemos voltar ao GitHub encerrar nosso processo de Pull request e fazermos um novo Pull request 
agora com a nova branch trabalhad com rebase e conflitos corrigidos. Para encerrar devo deixar uma mensagem, como por exemplo,
"Estou ecerrado o pull request para realizar novos ajustes"
--> 17- Devemos agora fazer um novo pedido de Pull request (lembre-se que para fazer isso precisamos estar no nosso repositório
do GitHub). Feito isso é de bom tom e favorece o registro histórico, deixamos uma mensagem dizenso que este processo de 
Pull request continua o processo inciado no pull request #num_do_Pull_Request
--> 18- Embora não se deva usar, é bom saber que existem opções para fazer o merge do pull request, vale a pena conferir,
existe por exemplo a opção de fazer o merge usando o rebase, mas isso, como você já sabe altera o Projetc History.
--> 19- Observe que a partir do merge criado, podemos apagar a branch que foi criada para gerar as alterações de trabalho.
Dentro do repositório do GitHub teremos a opção <Deletar a branch>
FORK WORKFLOW - LIMPEZA
Para isso devemos
--> 1- Acessamos nosso repositório local
--> 2- Devemos ir para a útlima branch criada
--> 3- Usamos o comando git branch -v (para visualizarmos quantas branchs estão ativas)
--> 4- Visualizadas as branchs, devemos excluí-las do repositório local e do repostitório remoto, para isso, usamos
git branch -D nome_da_branch (a diretiva -D para excluir independente se ela foi incorporada na master ou não)
devemos fazer isso para todas as branchs encontradas, mas lembre-se, você não pode excluir a branch que está trabalhando.
--> 5- Para exluir a branch que estava trabalhando, faça um <git checkout master> e agpra sim faça <git branch -D nome_branch>
--> 6- Para verificar se tudo esta ok localmente use <git branch -v>. Estando tudo ok, lembre-se, no GitHub ainda estamos com as branchs
--> 7- Para apagar um branch do GitHub estando no diretório local, usamos <git push -d origin nome_da_branch>
IMPORTANTE --> CONCEITOS DO GITHUB WORKFLOW
Alguns pré requisitos importantes:
--> Merge & Conflitos
--> Branches 
--> Rebase 
--> ISSUES
--> Pull Request
Fica ligado, GitHub Workflow não é Fork Workflow, ok.
Relembrando, no Fork Workflow cada colaborador deve fazer o clone (faz sua própria cópia de repositório), em seguida 
cada colaborador deve fazer o clone do seu repositório remoto para sua máquina local e depois submeter com o push para seu 
próprio repositório remoto (seu próprio Fork), a partir do seu Fork, cada desenvolvedor submete por request para o repositório central
e uma vez aprovado se integra ao repositório central, devendo se manter sincronizado o tempo tempo seu Fork com o repositório central.
Um ponto complexo desse processo é que quando cresce o número de colaboradores e cada colaborador precisando acompanhar o Fork dos demais 
essa integração acaba sendo muito complexa.
--> GitHub Workflow é o fluxo de trabalho simplificado facilitando cada desenvolvedor a entender o trabalho que cada um está realizando. 
Neste caso, cada desenvolvedor/colaborador pode fazer o clone direto do repositório central (upstream) não precisando do intermedifário 
que é o seu próprio Fork, desta forma, qualquer alteração feita por um colaborador e submetida ao upstream por push estará disponível a 
todos os demais no momento que ele fizer um pull. Como serão muito os commits, há uma estratégia para simplificar esse trabalho, essa
estratégia recebe o o nome de FEATURE BRANCH STRATEGY --> Nesta estratégia para cada pedaço de uma aplicação que estiver trabalhando
deverá criar uma branch separada da master, deverão haver muitas branchs ocorrendo em paralelo. O legal disso é que você poderá fazer 
N commits na branch que desenvolveu assim como todos os colaboradores que estiverem trabalhando no seu projeto poderão commitar na mesma
branch. Quando a branch estiver pronta para se integrar com a master é feito um Pull Request da mesma forma que era feito anteriormente.
REVISANDO O FLUXO GITHUB WORKFLOW
-->  git clone do repositório central (upstream) (faz um clone do repositório central)
--> git checkout -b, git add, git commit (trabalhando na sua própria branch)
--> git push (sobe para github)
--> Pull request (pull request sendo aceito ele irá se integrar a master)
--> git pull (para se manter atualizado e sincronizado)
GITHUB WORKFLOW --> FLUXO BÁSICO
--> 1- Faça um clone do repositório upstream
--> 2- Crie uma nova branch
--> 3- Faça as alterações desejadas
--> 4- Adicione na stage
--> 5- Faça o commit
--> 6- Feito tudo isso estamos prontos para colaborar faça um <git push origin nome_da_branch>
--> 7- É importante neste momento observar que nós não temos permissão para escrever neste repositório, pois se trata de um 
repositírio privado
--> 8- Para resolver isso, devemos acessar o repositório upstream e atribuir permissão para que o colaborador possa escrever 
no repositório. Para isso, é preciso se logar como dono do repositório e na opção SETTINGS fazer as devidas alterações.
--> 9- Em settings há uma guia COLLABORATORS é só entrar nesta guia e procurar pelo colaborador e lhe atribuir permissão.
Feito isso, o colaborar receberá um e-mail dizendo que ele tem permissão para colaborar com seu projeto. Esta mensagem
precisa ser aceita, para só então fazer parte do processo.
--> 10- A partir daí podemos fazer push <git push origin nome_da_branch>
--> 11- O próximo passo é realizar o Pull request
--> 12- Observe que neste caso o próprio colaborador poderá fazer o Merge do seu Pull request (o que não é uma opção
interessante). Sabendo disso, o próprio GitHub tem algo para resolver esse problema, embora você possa seguir fazendo
neste momento o Merge que você próprio gerou. A partir do Merge, teremos nossas alterações incormporadas na branch
master.
--> 13- Para fazermos um sincronismo, devemos fazer um <git chekout master> ir para nossa master e realizarmos o 
comando <git pull> que trará todas as atualizações para nossa máquina.
GITHUB WORKFLOW --> RESTRIÇÃO DE ACESSO 
Para controlar o acesso ao repositório upstream e evitar que aconteça algo como o demonstrado acima, o gitHub permite que
o dono do repositório upstream, na opção de Settings, na guia Branches defina restrições de controle e acesso.
--> Entrando em branches existe a opção Protected branches --> nesta opção há várias restrições que podem ser empregadas
para proteger e garantir a integridade de seu projeto.
GITHUB WORKFLOW PROCESSO DE REVIEW
--> 1- Voltamos nossa master ao estágio anterior com o comando git reset --hard head^ (isso se deve ao fato de tentarmos
realizar um push no repositório upstream e nos deparamos com restrições de acesso). Neste caso, faz-se necessário voltamos
atrás em nosso repositório para podermos seguir por outro caminho e solicitar o Pull request 
--> 2- Cria-se uma nova branch para tratar a demanda <git chekout -b nome_da_branch>
--> 3- Passos normais: adiciona a stage, faz-se o commit em seguida o push <git push origin nome_da_branch>
--> 4- Voltamos ao projeto e fazermos o pedido do Pull request 
--> 5- Note que agora teremos uma mensagem relativo ao nível de restrição que foi estipulado pelo dono do repositório
upstream 
--> 6- O dono do upstream terá em seu ambiente GitHub ferramentas para tratar da demanda, digo da restrição criada.
--> 7- Outra forma de estabelecer comunicação é clicando sobre o commit que gerou a solicitação de Pull request e fazer
os comentários no próprio texto/código com o sinal de (+)
--> 8- Por último há a opção de solicitar a revisão de código que fica localizada no canto superior direito do 
quadro de Review required há três opções, são elas: Comentário; Aprovar; Solicitar mudanças.
--> 9- Quando aprovada as alterações, o Merge estará disponível ao dono do upstream e ao dono da solicitação 
GITHUB WORKFLOW CONFLITOS E REBASE --> conflitos sempre os conflitos é preciso conviver com eles
Quando temos que trabalhar um branch específica, podemos usar o comando <git branch -a> para visualizarmos
as branchs que temos acesso. Nesta opção visualizaremos inclusive as branchs remotas.
--> Neste caso, quando você cria uma branch para tratar do assunto com o mesmo nome da branch remota, o 
github é inteligente o bastante para fazer a amarração e criar um Track (rastrear)
--> git checkout nome_da_branch_remota
--> Agora estamos na branch remota e podemos ver isso com o comando <git log --oneline>
--> Neste ponto você pode realizar a colaboração, fazer o commit com a opção am (adição e commit)
--> Observe que no upstream que faremos usaremos a opção -u (upstream --> repositório principal) <git push -u origin nome_da_branch>
--> Como outras pessoas podem contribuir para o mesmo evento pode acontecer de encontrarmos um conflito
--> Para tratar esse tipo de conflito, recomenda-se o uso do Rebase
--> Voltamos ao nosso usuário e realizamos um <git pull --rebase>. Esse comando irá gerar um conflito e abrirá a opção para que faça
os devidos ajustes.
--> Feito isso, salve a correção, adicione ao stage e continue com o commit <git add. && git rebase --continue>
--> Podemos verificar como ficou fazendo <git log --oneline>
--> Agora que temos o rebase realizado podemos voltar ao nosso push com <git push>
--> Para finalizar o processo devemos voltar ao GitHub e realizar o Merge encerrando assim o processo
UMA NOVA BRANCH SURGE NO LUGAR DA MASTER --> Alteração na branch principal
--> Cuidados com a Branch Master
--> Pode ser que algum usuário opte pela criação de uma branch deploy como uma tentativa de proteger a Master 
--> A Branch deploy, quando existente, faz parte do repositório upstream!
--> Existe uma opção no entanto, que faz com que a Master não seja mais o alvo do Pull request, para fazer isso siga os passos:
--> 1- No repositório upstream
--> 2- Vá em Settins e escolha a opção Branches
--> 3- Na opção branches no Default branch você poderá definir qual a branch será considerada branch Default
--> 4- Feito isso, sempre que forem fazer um Pull Request a branch que aparecerá como opção não será mais a Master 
e sim a branch seliconada na opção Settings.