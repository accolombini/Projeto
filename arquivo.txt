Testando git - primeiros passos
git init (ativa o git para o projeto em questão)
git config --global
git config --global user.name ... (nome do usuário)
git config --global user.email ... (email do usuário)
git config --global -l (lista todas as configurações)
git config --global core.editor <nome do editor desejado - notepad, por exemplo> (define um editor de trabalho para o git)
git status (status dos arquivos controlados pelo git)
git add <nome do arquivo> (adiciona o arquino na stage para que o git passe a controlá-lo)
git commit -m 'Uma mensagem clara do que foi feito desde a última alteração - procure ser claro aqui' <tira uma foto do arquivo naquele momento>
git add . (adiciona todos os arquivos do diretório controlado na stage)
git commit -am 'Uma mensagem clara do que foi feito desde a última alteração' (este comando realiza a adição na stage e realiza o commit de uma vez)
É importante destacar que o comando git commit -am só é válido para arquivos que já estão senfo rastreados (não se aplica na primeira vez)
git log (exibe o histórico de commits do(s) arquiv(s) controlado(s) --> Project history)
Atenção quanto o log não couber em uma tela aparecerá o sinal de : para sair da tela de log é preciso preciosar a tecla "q"
git checkout <código do commit exemplo: 071bb901c4cf20bb8b00f7c7497eee5f5d31b243> (nos poermite visualizar o arquivo naquele instante do snapshot)
git checkout master (para retornar para o master - arquivo atual ou último arquivo comitado)
git clone (https://nome do repositório criado no github para onde deverão ser clonados todos os nossos arquivos --> Neste caso não há necessidade do git init)
Atenção sempre que um novo arquivo for adicionado ao projeto ele precisa ser adicionado com o comando
git add <nome do arquivo>
E para o primeiro commit não se esqueça de usar a cláusula -m, assim:
git commit - m 'Comentário inicial do arquivo criado'
Para subir os arquivos comitados para o GitHub usamos o comando:
git push (este comando remete todos os arquivos comitados localmente para o repositório no GitHub)
Atenção --> cuidado com o repositório criado no GitHub e clonado localmente, procure ter um repositório especifico - ok
git pull (este comando traz para o repositório local tudo o que foi criado remotamente)
Vamos agora iniciar uma nova fase, neste momento trabalharemos com branchs e faremos merges das branches com a branch master
Para criar uma nova branch usamos o seguinte comando:
git branch <nome da branch> (simples assim)
Para visualizar as branches do projeto usamos o seguinte comando:
git branch (observe que neste caso não especificamos um mome --> nosso interesse é no retorno das branches dos projeto)
Para assessarmos a nova branch e realizarmos nosso trabalho todo nela --> digo, a partir daqui estaremos fazendo commits na nova-branch
git checkout <nome da branch> (este comando direciona nossas ações para a nova branch --> Nossos commits serão realizado aqui)
Para retornar para a branch master usamos o comando:
git checkout master (observe que estamos nomeando a git como master --> em palavras estamos acessando novamente a branch master)
Podemos rastrear os commites em uma branch específica da mesma forma que fazíamos na branch master ou seja, usando o comando:
git log  (você irá observar que todos os commites serão listados da branch master e da branch criada, lembra os commites são rastreados por históricos)
Atenção se voltarmos para a branch master iremos observar que o commit realizado na branch assim como o documento alterado não existem na branch master.
Vamos ver agora como realizar o merge de branches do tipo fast-forward (aquelas em que não foram realizados commits na branch master)
Importante --> o merge é ralizado a partir da branch master (na branch master eu peço para realizar o merge). Isso é feito com o comando:
git merge <nome da branch que desejo fazer o merge>
Um comando interessante será visto a seguir, seu objeto é apresentar um minigráfico da estrutura de commit, veja o comando:
git log --graph (este é um comando interessante quando se trabalha com várias branches)
Após fazermos o mege de uma branch com a master, podemos excluir a branch antiga, para isso usamos o comando:
git branch -d <nome da branch a ser excluída>
Posso agora fazer uma consulta às branches usando o comando a seguir:
git branch
Vamos agora realizar branches merge recursive strategy (neste caso foram realizados commits nas duas branch --> na master e na branch criada)
Podemos usar um comando um pouco mais interessante que nos permite criar um nova branch e entrar dentro dela, veja o comando a seguir:
git checkout -b <nome da branch>
Como poderemos term muita informação na tela e tornar o trabalho visulamente complexo, temos um comando que simplifica um pouco as coisas, veja a seguir:
git log --graph --oneline (ele diz para o graph resumir tudo a uma única linha)
Vamos agora trabalhar com conflitos nas branches --> isso ocorre quando alterações na master coincidem ou colidem com alterações feitas na branch.
Posso usar uma opção para sinalizar quais commites quero que sejam incluídos na branch, observe:
git commit -am 'mensagem' (observe o uso da flag -am ela inclui todas as alterações num único commit)
Atenção --> a resolução do conflito é competência do usuário, logo sua palavra final irá definir o que fica o que sai e a ordem.
Para que você insira seu projeto local na nuvem --> siga os passos a seguir:
Crie um repositório no GitHub simples --> não adicone nada
Na sua máquina use o comando:
git push --set-upstream projeto master (projeto é o nome de seu repositírio)
crie no git hub o arquivo readme.md
Na sua máquina local faça:
git pull (agora você esta sincroniado e atualizado)
Vamos falar agora da ferramenta ISSUES --> podemos usar esta ferramenta por vários motivos, são os mais relevantes:
1-  Relatar o Rastreio de Bugs --> nesta ISSUES queremos relatar bugs no projeto e acompanhar a solução destes bugs.
2- Sugestão de Ferramentas para o projeto
As ISSUES nos permitem fazermos um histórico de todas as alterações e uso das ferramentas, em outras palavras
conseguimos desta forma documentar passo a passo tudo o que foi feito para resolver bugs ou no desenvolvimento das novas ferramentas
Criando e resolvendo ISSUES:
1- No gitHub na guia do projeto que está trabalhando há um botão chamada ISSUES --> abre-se uma tela e nela você tem a possibilidade
de definir o título de sua ISSUES (uma boa dica --> as ISSUES pode auxiliá-lo a fazer uma boa gestão do seu projeto)
2- Cria-se a issue faz um clone no seu repositório local --> se for possível atenda de imediato a ISSUE e realize o commit
3- Se o commit realizado resolveu a ISSUE documente isso no GITHUB e faça um breve Comentário.
Criando branches
Você pode optar, por exemplo, por criar uma nova branch para atender a ISSUE criada, desta forma, você evita alterar a branch master
Nota: você ao realizar um commit para atender uma ISSUE específica após os comentários poderá acrescentar # <número da ISSUE>
O git entenderá que o commit feito refere-se a uma ISSUE específica, no caso, (número da ISSUE)
ATENÇÃO: após esse commit feito você deverá fazer um git push, correto? Pois é, isso não irá funcionar, pois o git entende que
os commits devem ser direcionados para a branch master, o que não é o caso neste momento. Para resolver isso, use o comando:
git push origin <branch destino>
ISSUES COMO FERRAMENTA COLABORATIVA
Observe que você pode desabilitar uma ISSUE, note que, por padrão, as ISSUES veêm ativadas, para desativá-las vá em
Features e desmarque a guia ISSUES
Num cenário colaboratívo, um colaborador também possui a autonomia para criar ISSUES e realizar solicitações sobre o projeto
Para isso, este colaborador deve acessar a página do projeto e criar uma ISSUE (processo anteriormente visto)
IMPORTANTE: se na área de comentário do commit for inserida a palavra "closes" seguida do id da ISSUE (# <NUM ISSUE)
Quando a palavra closes seguida do identificador da ISSUE for utilizada, ao realizar o git push a ISSUE será encerrada
Vamos agora ver como trabalhar com LABELS em ISSUES --> Para adicionar um LABEL, basta ir no github, selecionar a ISSUE
e escolher a opção LABEL, observe que o github tráz alguns LABELS padronizados que poderá usar diretamente, mas você é 
livre para criar os seus. Ao usar um LABEL você poderá fazer uma gestão visual do seu projeto através por exemplo das cores 
utilizadas na definição do seu LABEL
Outra prática importante é trabalhar com EMAILS E CITAÇÕES EM ISSUES
O interessante é que ao escrever, alterar produzir na ISSUE é enviado um e-mail a todos os colaboradores com interesse na ISSUE
em questão. O colaborador pode enviar uma mensagem para uma pessoa específica, para isso, basta usar o símbolo de @ e o nome
do colaborador que deseja enviar a mensagem
ASSINATURAS e ENCERRAMENTO DAS ISSUES
No topo do lado direito no github há a opção Assignees onde é possível sinalizar quem saão as pessoas cadastradas para assinar 
essa ISSUE --> essa ferramenta ajuda pessoas a acompanharem as ações realizadas numa ISSUE.
